<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="description" content="Controlador para rodillo de entrenamiento Decathlon D100">
    <title>Smart Trainer Controller</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@500;600;700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üö¥</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #0a0a0a;
            color: #ffffff;
            overflow-x: hidden;
        }
        
        #app {
            width: 100%;
            min-height: 100%;
            height: 100%;
        }
        
        /* Vista Home: fondo ambiental animado (wrapper a ancho/alto completo) */
        .home-view-bg {
            position: relative;
            width: 100%;
            min-height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(0, 212, 170, 0.05) 0%, rgba(10, 10, 10, 1) 70%);
            background-size: 200% 200%;
            animation: ambientBgPulse 10s ease infinite;
        }
        @keyframes ambientBgPulse {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 212, 170, 0.4); opacity: 1; }
            50% { box-shadow: 0 0 35px rgba(0, 212, 170, 0.6); opacity: 0.9; }
        }
        /* Cards: overlay de rejilla t√©cnica */
        .card-grid-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0.08;
            background-image: linear-gradient(rgba(0, 212, 170, 0.15) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 212, 170, 0.15) 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: inherit;
        }
        /* Cards desbloqueadas: "encendidas" */
        .card-unlocked {
            animation: cardUnlockedGlow 0.6s ease-out forwards;
            box-shadow: 0 0 28px rgba(0, 212, 170, 0.35), 0 8px 32px rgba(0, 0, 0, 0.4);
            border-color: rgba(0, 212, 170, 0.5) !important;
        }
        @keyframes cardUnlockedGlow {
            from { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); }
            to { box-shadow: 0 0 28px rgba(0, 212, 170, 0.35), 0 8px 32px rgba(0, 0, 0, 0.4); }
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        @keyframes connectButtonShine {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        .connect-btn-pro {
            background: linear-gradient(90deg, #00d4aa 0%, #00f2fe 25%, #00d4aa 50%, #00f2fe 75%, #00d4aa 100%) !important;
            background-size: 200% 100% !important;
            animation: connectButtonShine 5s ease-in-out infinite;
        }
        
        /* Swiper de modos en portada: scroll horizontal sin barra visible */
        .home-mode-swiper::-webkit-scrollbar {
            display: none;
        }
        
        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* Home hero: logo animado + t√≠tulo gradiente */
        .logo-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid transparent;
            border-top-color: #00d4aa;
            border-right-color: #3b82f6;
            animation: logoRingSpin 3s linear infinite;
            box-shadow: 0 0 20px rgba(0, 212, 170, 0.25);
        }
        @keyframes logoRingSpin {
            to { transform: rotate(360deg); }
        }
        .hero-title-gradient {
            background: linear-gradient(to right, #fff, #a5f3fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Settings: responsive */
        .settings-view {
            padding: clamp(12px, 4vw, 24px) !important;
        }
        .settings-zones-wrap {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-top: 8px;
        }
        .settings-zones-wrap table {
            min-width: 280px;
        }
        @media (max-width: 600px) {
            .settings-view .settings-field-group {
                grid-template-columns: 1fr !important;
            }
            .settings-view .settings-actions {
                flex-direction: column;
                align-items: stretch;
            }
            .settings-view .settings-actions button {
                width: 100%;
                justify-content: center;
            }
            .settings-view .settings-zwift-row {
                flex-direction: column;
                align-items: stretch;
            }
            .settings-view .settings-zwift-row .settings-zwift-btn {
                width: 100%;
                justify-content: center;
                min-height: 44px;
            }
            .settings-view .settings-zwift-row .settings-zwift-connect {
                order: -1;
            }
        }
    </style>
</head>
<body>
    <div id="app"></div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module" src="src/app.js"></script>
    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Sistema de Actualizaci√≥n PWA - Smart Trainer
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const UpdateManager = {
            registration: null,
            waitingWorker: null,
            updateToastVisible: false,
            isRefreshing: false, // Evitar m√∫ltiples recargas
            userRequestedUpdate: false, // Solo recargar si el usuario pidi√≥ la actualizaci√≥n
            
            /**
             * Inicializar el Service Worker y sistema de actualizaciones
             */
            async init() {
                if (!('serviceWorker' in navigator)) {
                    console.log('‚ö†Ô∏è Service Worker no soportado');
                    return;
                }
                
                try {
                    // Registrar SW
                    this.registration = await navigator.serviceWorker.register('./sw.js', {
                        scope: './'
                    });
                    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                        console.log('SW:', this.registration.scope);
                    }
                    
                    // Detectar actualizaciones al registrar
                    this.checkForWaitingWorker();
                    
                    // Escuchar nuevas instalaciones
                    this.registration.addEventListener('updatefound', () => {
                        this.onUpdateFound();
                    });
                    
                    // Escuchar cuando el SW controlador cambia (despu√©s de skipWaiting)
                    // SOLO recargar si el usuario solicit√≥ la actualizaci√≥n expl√≠citamente
                    navigator.serviceWorker.addEventListener('controllerchange', () => {
                        if (this.isRefreshing) return; // Evitar loop
                        if (!this.userRequestedUpdate) return;
                        this.isRefreshing = true;
                        window.location.reload();
                    });
                    
                    // Comprobar actualizaciones al arrancar (solo una vez)
                    setTimeout(() => this.checkForUpdates(), 1000);
                    
                    // Comprobar actualizaciones peri√≥dicamente (cada 30 min)
                    setInterval(() => this.checkForUpdates(), 30 * 60 * 1000);
                    
                    // Tambi√©n al volver de segundo plano
                    document.addEventListener('visibilitychange', () => {
                        if (document.visibilityState === 'visible') {
                            this.checkForUpdates();
                        }
                    });
                    
                } catch (error) {
                    console.error('‚ö†Ô∏è Error registrando Service Worker:', error);
                }
            },
            
            /**
             * Comprobar si hay un SW esperando cuando cargamos (solo guardar referencia, no mostrar toast).
             * El toast solo se muestra cuando onUpdateFound detecta una nueva versi√≥n en esta sesi√≥n.
             */
            checkForWaitingWorker() {
                if (this.registration?.waiting) {
                    this.waitingWorker = this.registration.waiting;
                }
            },
            
            /**
             * Se ha encontrado una actualizaci√≥n
             */
            onUpdateFound() {
                const newWorker = this.registration.installing;
                if (!newWorker) return;
                
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed') {
                        if (navigator.serviceWorker.controller) {
                            // Hay una versi√≥n anterior - mostrar toast solo en esta sesi√≥n
                            this.waitingWorker = newWorker;
                            this.showUpdateToast();
                        } else {
                            // Primera instalaci√≥n - no mostrar toast
                        }
                    }
                });
            },
            
            /**
             * Forzar comprobaci√≥n de actualizaciones
             */
            async checkForUpdates() {
                if (!this.registration) return;
                try {
                    await this.registration.update();
                } catch (error) {
                    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                        console.warn('Actualizaci√≥n SW:', error.message);
                    }
                }
            },
            
            /**
             * Mostrar toast de actualizaci√≥n disponible (solo cuando hay nueva versi√≥n en esta sesi√≥n)
             */
            showUpdateToast() {
                if (this.updateToastVisible) return;
                this.updateToastVisible = true;
                
                const toast = document.createElement('div');
                toast.id = 'update-toast';
                toast.innerHTML = `
                    <style>
                        #update-toast .update-toast-box {
                            position: fixed;
                            bottom: 16px;
                            left: 50%;
                            transform: translateX(-50%);
                            background: rgba(26,26,26,0.95);
                            border: 1px solid rgba(0,212,170,0.25);
                            border-radius: 10px;
                            padding: 10px 14px;
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            box-shadow: 0 4px 20px rgba(0,0,0,0.35);
                            z-index: 10000;
                            animation: updateToastSlide 0.25s ease-out;
                            max-width: min(360px, calc(100vw - 24px));
                        }
                        #update-toast .update-toast-msg { flex: 1; min-width: 0; font-size: 13px; color: #e5e5e5; font-weight: 500; }
                        #update-toast .update-toast-btn { background: #00d4aa; color: #000; border: none; border-radius: 6px; padding: 6px 14px; font-size: 13px; font-weight: 600; cursor: pointer; white-space: nowrap; }
                        #update-toast .update-toast-btn:disabled { opacity: 0.7; cursor: not-allowed; }
                        #update-toast .update-toast-close { background: transparent; border: none; color: #888; cursor: pointer; padding: 4px; display: flex; align-items: center; justify-content: center; }
                        @media (max-width: 380px) {
                            #update-toast .update-toast-box { flex-wrap: wrap; padding: 10px 12px; gap: 8px; }
                            #update-toast .update-toast-msg { flex: 1 1 100%; order: 1; }
                            #update-toast .update-toast-btn { order: 2; }
                            #update-toast .update-toast-close { order: 3; margin-left: auto; }
                        }
                        @keyframes updateToastSlide {
                            from { transform: translateX(-50%) translateY(80px); opacity: 0; }
                            to { transform: translateX(-50%) translateY(0); opacity: 1; }
                        }
                        @keyframes updateToastSlideOut {
                            to { transform: translateX(-50%) translateY(80px); opacity: 0; }
                        }
                    </style>
                    <div class="update-toast-box">
                        <span class="update-toast-msg">Nueva versi√≥n disponible</span>
                        <button type="button" class="update-toast-btn" data-action="apply">Actualizar</button>
                        <button type="button" class="update-toast-close" data-action="dismiss" title="Cerrar" aria-label="Cerrar">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                        </button>
                    </div>
                `;
                
                const btnApply = toast.querySelector('[data-action="apply"]');
                const btnDismiss = toast.querySelector('[data-action="dismiss"]');
                btnApply.addEventListener('click', () => UpdateManager.applyUpdate());
                btnDismiss.addEventListener('click', () => UpdateManager.dismissToast());
                document.body.appendChild(toast);
            },
            
            /**
             * Aplicar la actualizaci√≥n
             */
            applyUpdate() {
                if (!this.waitingWorker) {
                    this.userRequestedUpdate = true;
                    this.forceRefresh();
                    return;
                }
                this.userRequestedUpdate = true;
                const toast = document.getElementById('update-toast');
                const btn = toast?.querySelector('[data-action="apply"]');
                if (btn) {
                    btn.textContent = 'Actualizando...';
                    btn.disabled = true;
                }
                this.waitingWorker.postMessage({ type: 'SKIP_WAITING' });
            },
            
            /**
             * Forzar recarga limpia (limpiar cache)
             */
            async forceRefresh() {
                this.userRequestedUpdate = true;
                this.isRefreshing = true;
                if (this.registration?.active) {
                    this.registration.active.postMessage({ type: 'FORCE_UPDATE' });
                }
                // Esperar un momento y recargar
                setTimeout(() => window.location.reload(true), 500);
            },
            
            /**
             * Cerrar el toast (sin actualizar)
             */
            dismissToast() {
                const toast = document.getElementById('update-toast');
                if (toast) {
                    const box = toast.querySelector('.update-toast-box');
                    if (box) box.style.animation = 'updateToastSlideOut 0.25s ease-out forwards';
                    setTimeout(() => {
                        toast.remove();
                        this.updateToastVisible = false;
                    }, 250);
                }
            }
        };
        
        // Inicializar al cargar
        window.addEventListener('load', () => UpdateManager.init());
        
        // =============================================
        // PWA Install Management
        // =============================================
        const PWA_INSTALLED_KEY = 'smart-trainer-pwa-installed';
        let deferredPrompt = null;

        // Verificar si est√° en modo PWA (standalone, etc.)
        const isRunningAsPWA = () => {
            const displayModes = ['standalone', 'fullscreen', 'minimal-ui', 'window-controls-overlay'];
            for (const mode of displayModes) {
                if (window.matchMedia && window.matchMedia(`(display-mode: ${mode})`).matches) {
                    return true;
                }
            }
            if (window.navigator && window.navigator.standalone === true) return true;
            return false;
        };

        // Verificar si ya est√° instalada
        window.isPWAInstalled = function() {
            if (isRunningAsPWA()) return true;
            if (localStorage.getItem(PWA_INSTALLED_KEY) === 'true') return true;
            return false;
        };

        // Saber si hay prompt pendiente
        window.hasPWAInstallPrompt = function() {
            return !!deferredPrompt;
        };

        // Capturar el evento beforeinstallprompt
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('[PWA] beforeinstallprompt received');
            e.preventDefault();
            
            // Si ya est√° instalada, ignorar
            if (window.isPWAInstalled()) {
                console.log('[PWA] Already installed, ignoring prompt');
                deferredPrompt = null;
                return;
            }
            
            deferredPrompt = e;
            console.log('[PWA] Prompt saved, dispatching pwa-installable');
            window.dispatchEvent(new CustomEvent('pwa-installable', { detail: true }));
        });

        // Funci√≥n global para instalar la PWA
        window.installPWA = async function() {
            console.log('[PWA] installPWA called, deferredPrompt:', !!deferredPrompt);
            
            if (!deferredPrompt) {
                console.log('[PWA] No deferred prompt available');
                window.dispatchEvent(new CustomEvent('pwa-install-unavailable'));
                return false;
            }
            
            try {
                console.log('[PWA] Calling prompt()...');
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log('[PWA] User choice:', outcome);
                deferredPrompt = null;
                
                if (outcome === 'accepted') {
                    localStorage.setItem(PWA_INSTALLED_KEY, 'true');
                    window.dispatchEvent(new CustomEvent('pwa-installed', { detail: outcome }));
                    return true;
                }
                return false;
            } catch (error) {
                console.error('[PWA] Error installing:', error);
                deferredPrompt = null;
                return false;
            }
        };

        // Detectar cuando el sistema confirma que la app fue instalada
        window.addEventListener('appinstalled', () => {
            console.log('[PWA] appinstalled event received');
            deferredPrompt = null;
            localStorage.setItem(PWA_INSTALLED_KEY, 'true');
            window.dispatchEvent(new CustomEvent('pwa-installed', { detail: 'installed' }));
        });
        
        // Debug: mostrar estado inicial
        console.log('[PWA] Initial state - isRunningAsPWA:', isRunningAsPWA(), 'isPWAInstalled:', window.isPWAInstalled());
    </script>
</body>
</html>
