<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="description" content="Controlador para rodillo de entrenamiento Decathlon D100">
    <title>Smart Trainer Controller</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@500;600;700;800&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üö¥</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: #0a0a0a;
            color: #ffffff;
            overflow-x: hidden;
        }
        
        #app {
            width: 100%;
            min-height: 100%;
        }
        
        /* Vista Home: fondo ambiental animado */
        .home-view-bg {
            position: relative;
            min-height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(0, 212, 170, 0.05) 0%, rgba(10, 10, 10, 1) 70%);
            background-size: 200% 200%;
            animation: ambientBgPulse 10s ease infinite;
        }
        @keyframes ambientBgPulse {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 212, 170, 0.4); opacity: 1; }
            50% { box-shadow: 0 0 35px rgba(0, 212, 170, 0.6); opacity: 0.9; }
        }
        /* Cards: overlay de rejilla t√©cnica */
        .card-grid-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0.08;
            background-image: linear-gradient(rgba(0, 212, 170, 0.15) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 212, 170, 0.15) 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: inherit;
        }
        /* Cards desbloqueadas: "encendidas" */
        .card-unlocked {
            animation: cardUnlockedGlow 0.6s ease-out forwards;
            box-shadow: 0 0 28px rgba(0, 212, 170, 0.35), 0 8px 32px rgba(0, 0, 0, 0.4);
            border-color: rgba(0, 212, 170, 0.5) !important;
        }
        @keyframes cardUnlockedGlow {
            from { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); }
            to { box-shadow: 0 0 28px rgba(0, 212, 170, 0.35), 0 8px 32px rgba(0, 0, 0, 0.4); }
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        @keyframes connectButtonShine {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        .connect-btn-pro {
            background: linear-gradient(90deg, #00d4aa 0%, #00f2fe 25%, #00d4aa 50%, #00f2fe 75%, #00d4aa 100%) !important;
            background-size: 200% 100% !important;
            animation: connectButtonShine 5s ease-in-out infinite;
        }
        
        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <div id="app"></div>
    <script type="module" src="src/app.js"></script>
    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Sistema de Actualizaci√≥n PWA - Smart Trainer
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const UpdateManager = {
            registration: null,
            waitingWorker: null,
            updateToastVisible: false,
            isRefreshing: false, // Evitar m√∫ltiples recargas
            userRequestedUpdate: false, // Solo recargar si el usuario pidi√≥ la actualizaci√≥n
            
            /**
             * Inicializar el Service Worker y sistema de actualizaciones
             */
            async init() {
                if (!('serviceWorker' in navigator)) {
                    console.log('‚ö†Ô∏è Service Worker no soportado');
                    return;
                }
                
                try {
                    // Registrar SW
                    this.registration = await navigator.serviceWorker.register('./sw.js', {
                        scope: './'
                    });
                    console.log('‚úÖ Service Worker registrado:', this.registration.scope);
                    
                    // Detectar actualizaciones al registrar
                    this.checkForWaitingWorker();
                    
                    // Escuchar nuevas instalaciones
                    this.registration.addEventListener('updatefound', () => {
                        this.onUpdateFound();
                    });
                    
                    // Escuchar cuando el SW controlador cambia (despu√©s de skipWaiting)
                    // SOLO recargar si el usuario solicit√≥ la actualizaci√≥n expl√≠citamente
                    navigator.serviceWorker.addEventListener('controllerchange', () => {
                        if (this.isRefreshing) return; // Evitar loop
                        if (!this.userRequestedUpdate) {
                            // El SW cambi√≥ pero el usuario no lo pidi√≥ (ej: DevTools "Update on reload")
                            console.log('üîÑ Service Worker actualizado en background');
                            return;
                        }
                        this.isRefreshing = true;
                        console.log('üîÑ Aplicando actualizaci√≥n...');
                        window.location.reload();
                    });
                    
                    // Comprobar actualizaciones al arrancar (solo una vez)
                    setTimeout(() => this.checkForUpdates(), 1000);
                    
                    // Comprobar actualizaciones peri√≥dicamente (cada 30 min)
                    setInterval(() => this.checkForUpdates(), 30 * 60 * 1000);
                    
                    // Tambi√©n al volver de segundo plano
                    document.addEventListener('visibilitychange', () => {
                        if (document.visibilityState === 'visible') {
                            this.checkForUpdates();
                        }
                    });
                    
                } catch (error) {
                    console.error('‚ö†Ô∏è Error registrando Service Worker:', error);
                }
            },
            
            /**
             * Comprobar si hay un SW esperando cuando cargamos
             */
            checkForWaitingWorker() {
                if (this.registration?.waiting) {
                    this.waitingWorker = this.registration.waiting;
                    this.showUpdateToast();
                }
            },
            
            /**
             * Se ha encontrado una actualizaci√≥n
             */
            onUpdateFound() {
                const newWorker = this.registration.installing;
                if (!newWorker) return;
                
                console.log('üîÑ Descargando nueva versi√≥n...');
                
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed') {
                        if (navigator.serviceWorker.controller) {
                            // Hay una versi√≥n anterior - mostrar toast de actualizaci√≥n
                            console.log('üîÑ Nueva versi√≥n lista para instalar');
                            this.waitingWorker = newWorker;
                            this.showUpdateToast();
                        } else {
                            // Primera instalaci√≥n - no mostrar nada
                            console.log('‚úÖ App instalada por primera vez');
                        }
                    }
                });
            },
            
            /**
             * Forzar comprobaci√≥n de actualizaciones
             */
            async checkForUpdates() {
                if (!this.registration) return;
                
                try {
                    await this.registration.update();
                    console.log('üîç Comprobaci√≥n de actualizaciones completada');
                } catch (error) {
                    console.log('‚ö†Ô∏è Error comprobando actualizaciones:', error.message);
                }
            },
            
            /**
             * Mostrar toast de actualizaci√≥n disponible
             */
            showUpdateToast() {
                if (this.updateToastVisible) return;
                this.updateToastVisible = true;
                
                // Crear toast
                const toast = document.createElement('div');
                toast.id = 'update-toast';
                toast.innerHTML = `
                    <div style="
                        position: fixed;
                        bottom: 24px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
                        border: 1px solid rgba(0, 212, 170, 0.3);
                        border-radius: 12px;
                        padding: 16px 20px;
                        display: flex;
                        align-items: center;
                        gap: 16px;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 20px rgba(0, 212, 170, 0.1);
                        z-index: 10000;
                        animation: slideUp 0.3s ease-out;
                        max-width: calc(100vw - 32px);
                    ">
                        <div style="
                            width: 40px;
                            height: 40px;
                            background: rgba(0, 212, 170, 0.15);
                            border-radius: 10px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            flex-shrink: 0;
                        ">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#00d4aa" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="7 10 12 15 17 10"/>
                                <line x1="12" y1="15" x2="12" y2="3"/>
                            </svg>
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; color: #fff; margin-bottom: 2px;">Nueva versi√≥n disponible</div>
                            <div style="font-size: 13px; color: #888;">Actualiza para obtener las √∫ltimas mejoras</div>
                        </div>
                        <button onclick="UpdateManager.applyUpdate()" style="
                            background: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);
                            color: #000;
                            border: none;
                            border-radius: 8px;
                            padding: 10px 20px;
                            font-weight: 600;
                            font-size: 14px;
                            cursor: pointer;
                            white-space: nowrap;
                            transition: transform 0.15s ease, box-shadow 0.15s ease;
                        " onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,212,170,0.3)'"
                           onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                            Actualizar
                        </button>
                        <button onclick="UpdateManager.dismissToast()" style="
                            background: transparent;
                            border: none;
                            color: #666;
                            cursor: pointer;
                            padding: 8px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        " title="Cerrar">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"/>
                                <line x1="6" y1="6" x2="18" y2="18"/>
                            </svg>
                        </button>
                    </div>
                `;
                
                // A√±adir estilos de animaci√≥n
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideUp {
                        from { transform: translateX(-50%) translateY(100px); opacity: 0; }
                        to { transform: translateX(-50%) translateY(0); opacity: 1; }
                    }
                    @keyframes slideDown {
                        from { transform: translateX(-50%) translateY(0); opacity: 1; }
                        to { transform: translateX(-50%) translateY(100px); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(toast);
            },
            
            /**
             * Aplicar la actualizaci√≥n
             */
            applyUpdate() {
                if (!this.waitingWorker) {
                    // No hay worker esperando, forzar recarga limpia
                    this.userRequestedUpdate = true;
                    this.forceRefresh();
                    return;
                }
                
                // Marcar que el usuario solicit√≥ la actualizaci√≥n
                this.userRequestedUpdate = true;
                
                // Mostrar estado de "actualizando"
                const toast = document.getElementById('update-toast');
                if (toast) {
                    toast.querySelector('button').textContent = 'Actualizando...';
                    toast.querySelector('button').disabled = true;
                }
                
                // Enviar mensaje al SW para que se active
                this.waitingWorker.postMessage({ type: 'SKIP_WAITING' });
            },
            
            /**
             * Forzar recarga limpia (limpiar cache)
             */
            async forceRefresh() {
                this.userRequestedUpdate = true;
                this.isRefreshing = true;
                if (this.registration?.active) {
                    this.registration.active.postMessage({ type: 'FORCE_UPDATE' });
                }
                // Esperar un momento y recargar
                setTimeout(() => window.location.reload(true), 500);
            },
            
            /**
             * Cerrar el toast (sin actualizar)
             */
            dismissToast() {
                const toast = document.getElementById('update-toast');
                if (toast) {
                    toast.querySelector('div').style.animation = 'slideDown 0.3s ease-out forwards';
                    setTimeout(() => {
                        toast.remove();
                        this.updateToastVisible = false;
                    }, 300);
                }
            }
        };
        
        // Inicializar al cargar
        window.addEventListener('load', () => UpdateManager.init());
        
        // Detectar si se puede instalar como PWA
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('üì≤ PWA instalable disponible');
            // Disparar evento personalizado para que la app sepa que puede mostrar el bot√≥n
            window.dispatchEvent(new CustomEvent('pwa-installable', { detail: true }));
        });
        
        // Funci√≥n global para instalar la PWA
        window.installPWA = async function() {
            if (!deferredPrompt) {
                console.log('‚ö†Ô∏è PWA no est√° lista para instalar');
                return false;
            }
            
            try {
                // Mostrar el prompt de instalaci√≥n
                deferredPrompt.prompt();
                
                // Esperar a que el usuario responda
                const { outcome } = await deferredPrompt.userChoice;
                
                if (outcome === 'accepted') {
                    console.log('‚úÖ Usuario acept√≥ instalar la PWA');
                } else {
                    console.log('‚ùå Usuario rechaz√≥ instalar la PWA');
                }
                
                // Limpiar el prompt
                deferredPrompt = null;
                
                // Disparar evento para ocultar el bot√≥n
                window.dispatchEvent(new CustomEvent('pwa-installed', { detail: outcome }));
                
                return outcome === 'accepted';
            } catch (error) {
                console.error('Error al instalar PWA:', error);
                return false;
            }
        };
        
        // Detectar si la app ya est√° instalada
        window.addEventListener('appinstalled', () => {
            console.log('‚úÖ PWA instalada');
            deferredPrompt = null;
            window.dispatchEvent(new CustomEvent('pwa-installed', { detail: 'installed' }));
        });
    </script>
</body>
</html>
